\section{Transport Protocol}

\subsection{Discoverable Server}
To establish a cryptographic session between a client and a discoverable server,
we base the cryptographic handshake on the Noise XX handshake
pattern~\cite{noise}. 

\begin{figure}[h]
	\centering
	\includegraphics[width=0.6\columnwidth]{figures/crypto_handshake_discoverable.pdf}
	\caption{\textbf{Discoverable Server Session Establishment}---%
	\textnormal{}
	}
	\label{fig:crypto_handshake_discoverable}
	\vspace{-5pt}
\end{figure}


\vspace{5pt} \textit{1) Client Hello:}\quad 
Initially, both the client and server are unauthenticated. The client begins by
sending a Client Hello to the server. The client creates an ephemeral key pair ($e_c^{priv}, e_c^{pub}$) and chooses the
protocol name (or version?). The protocol name (\TODO{why do we need proto
name?}), message type (client hello := \texttt{0x1}), protocol version, reserved
bytes, and the
client ephemeral public key are absorbed into the duplex object, and a message
authentication code (MAC) is squeezed out. The client then begins the
session handshake by sending the Client Hello, which is a concatenation of the
input bytes to the duplex object with the MAC (Figure~\ref{fig:client_hello}).

\input{bytefields/client_hello.tex}

\vspace{5pt} \textit{2) Server Hello:}\quad 
When the server receives the Client Hello \todo{what about lost hellos?}, it performs the same logic as the
client, absorbing the protocol name, message type, protocol version, and
client's ephemeral public key into its own duplex object to verify the MAC
attached to the Client Hello. If the MAC matches, the server
replies with a Server Hello, otherwise it does not respond to the client.

The server creates its own ephemeral key pair ($e_s^{priv}, e_s^{pub}$) and
performs a Diffie-Hellman between the client ephemeral public key and the server
ephemeral public key. The result of this Diffie-Hellman is used to create a new
chaining key $ ck := \texttt{DH}(e_s^{priv}, e_c^{pub} ) $. 
Continuing with the duplex object, the server absorbs the message type (server
hello := \texttt{0x2}), reserved bytes, the server ephemeral public key, and the
chaining key. The server also encrypts its
ephemeral private key via AEAD and uses the resulting ciphertext as a cookie.
The cookie construction is as follows: $\texttt{cookie} := \texttt{AEAD}(K_r,
e_s^{priv}, H(e_c^{pub}, \texttt{clientIP}, \texttt{clientPort})) $, where $K_r$
is a key that is rotated every 2 minutes. \todo{what is this used for again?}
The cookie is also absorbed into the duplex object and a MAC is squeezed out.
The Server Hello consists of the message type (server hello := 0x2), reserved
bytes, server ephemeral public key, the cookie, and the MAC
(Figure~\ref{fig:server_hellp}).

\input{bytefields/server_hello.tex}

\vspace{5pt} \textit{3) Client Acknowledgment:}\quad 
When the client receives the Server Hello, it likewise computes the shared
chaining key $ ck := \texttt{DH}(e_c^{priv}, e_s^{pub}) $ and absorbs the
message type, reserved bytes, server ephemeral public key, chaining key, and
cookie. The client then verifies the MAC with the output of its duplex object.

The third message of the handshake protocol is the client acknowledgment
(Figure~\ref{fig:client_ack}). It includes the message type (Client
Ack := \texttt{0x3}), reserved bytes, and the client ephemeral public key. It
echoes the cookie back to the server and also includes an SNI. The SNI consists
of a 1 byte type indicator of the server ID (e.g., domain name, IoT serial
number) concatenated with a 255 byte server ID. The fields of the Client
Acknowledgment message are inputs into the client's duplex object, and the
squeezed output MAC is appended.

\input{bytefields/client_ack.tex}

\vspace{5pt} \textit{4) Server Authentication:}\quad 

At this point, both client and server... They still need to be authenticated to
each other.
\TODO{}

\input{bytefields/server_auth.tex}

\vspace{5pt} \textit{5) Client Authentication:}\quad 
\TODO{}

\input{bytefields/client_auth.tex}


The SSTP discoverable server handshake completes after the client
authentication. At this point, the client and server share a secret session key
derived from the client ephemeral, server ephemeral, client static, and server
static, which provides \TODO{what}. Subsequent transport messages are sent
through one or more \emph{channels} within the encrypted session.

\subsection{Channel Multiplexing}


SSTP supports multiple channels within a single encrypted session. It borrows
and simplifies aspects of QUIC streams and TCP to implement a reliable stream
abstraction, but provides the option for unreliable data delivery within a
channel as well.

We show the format of an SSTP transport message in
Figure~\ref{fig:transport_message}. Channel multiplexing is implemented by
encapsulating a single \emph{channel frame} (green) within the Encrypted Data segment of
the transport message. Each channel is identified by the Channel ID in the frame
header. We statically allocate even-numbered channel IDs for client-initiated
channels and odd IDs for server-initiated channels to avoid collisions during
the channel creation process.
% note: QUIC actually does odd for client, even for server. 
Channels are created through a 2-way handshake when either the client
or server sends a Channel Initiation Request and the other party successfully
replies with a Channel Initiation Response. Channels are closed when both
parties send and receive a frame with the \texttt{FIN} bit set to one. Multiple
channels can be created and closed repeatedly without tearing down the entire
SSTP session.

\input{bytefields/transport_message.tex}

\subsection{Authentication and Encryption}
After the initial SSTP handshake messages, the payload (Encrypted Data) segment
of all SSTP transport messages are authenticated and encrypted. \todo{Wilson: more details}

\subsection{Channel Creation}

The channel creation 2-way handshake begins when one party (the initiator) sends
a message to the other (the responder) with the
\texttt{REQ} bit set to one and the Frame Number set to 0. This initial message
is the Channel Initiation Request. All initial handshake messages for a channel
must begin with Frame Number 0.
The Channel Initiation Request contains a non-negotiable Channel ID and Channel Type (reliable or
unreliable) chosen by the initiator, as well as the initiator's Receive Window
Size. If any of these values need to change during the lifetime of
the channel, the channel is closed and a new one is created. Additionally, any
initial data for the channel can be sent in the Data field.

Upon receipt of a Channel Initiation Request, the responder
replies with a Channel Initiation Response. Channel Initiation Responses have
the \texttt{RESP} bit set to 1 and Frame Number 0. 
% A frame cannot both be a request and a response. 
The responder chooses to accept or reject the
channel creation by setting the \texttt{ACC} bit to the appropriate value (1 for
accept, 0 for reject). The Channel ID and Channel Type are echoed back to the
initiator, and the responder sets its own Receive Window Size.

After both request and response frames have been received, the channel has been
created from the perspective of both the initiator and the responder. SSTP only
requires a 2-way handshake because all initial Frame Numbers start at 0.
Spoofing attacks caused by non-random initial sequence numbers are prevented
since the entire frame is authenticated and encrypted within the transport message.

Channel creation handshake messages do not use explicit acknowledgments, as the
response is implicitly an acknowledgment of the request. If the initiator does
not receive a Channel Initiation Response for some period of time after sending
a request, it will assume that the Channel was not
created and that either the request was lost or the response was lost. In either
case, it will retransmit a request. If the response was lost, the responder may
already be sending channel data since it assumes the channel has been created.
The initiator ignores all channel data and resends Channel Initiation Requests
until it properly receives a Channel Initiation Response. If the
responder receives a duplicate request, the newer request takes precedence and
all state from the previous half-channel is destroyed, and a new channel is
created from the new request.

\subsection{Reliable Channels}
We use Frame Numbers and Acknowledgment Numbers for a simple implementation of
reliable transmission based on TCP. We consider congestion control to be
orthogonal to reliable transmission within a channel and leave it to future
work. 

The Frame Number is a 32-bit sequence number starting at 0 that counts
individual frames. Channel handshake messages always have Frame Number
0, and data always starts at Frame Number 1. In the
event that the Frame Number reaches the maximum value of $2^{32} - 1$, it will
wraparound back to 0, with \texttt{REQ} and \texttt{RESP} flags unset so as to
not interpret data messages as a new handshake message. Frame Numbers also
encode the order of the application data for stream reassembly at the receiver.

When an SSTP message is sent, a retransmission timer is started to recover from
loss in the network. If the message is received, the responder will reply with an acknowledgment for the next Frame Number
expected. Every data message will contain an Acknowledgment Number. This 32-bit Acknowledgment Number replaces the 32-bits of Window Size,
Channel Type, and Reserved fields that are only used during channel creation,
which saves 4 bytes of control data in every message. If no acknowledgment is
received before the retransmission timer expires, the frame is resent. 

\subsection{Unreliable Channels}
For unreliable channels, both client and server can begin
sending data to each other without needing to check proper receival or ordering
of frames.
However, unlike vanilla UDP, this is not a connectionless communication mode.
Both a session and a channel need to be created beforehand, and all frames are
authenticated and encrypted by virtue of being encapsulated in an SSTP transport
message. Both the Frame Number and the Acknowledgment Number fields can be ignored.

\subsection{Channel Tear Down}
To close a channel, we use the four-way \texttt{FIN-ACK/FIN-ACK} handshake
common in most TCP implementations. If channel frames are received by an
endpoint after a
\texttt{FIN} has been sent, the endpoint will continue sending acknowledgments
with the \texttt{FIN} flag sent to signal closing the channel. Once both
endpoints have received acknowledgments for both \texttt{FIN}s, the channel is
closed and the Channel ID can be reused within the SSTP session.
% We do not need RST flag. In TCP this is usually used when a segment arrives
% that is not intended for the current connection, but since all frames are
% authenticated this won't occur















\section{Transport Protocol}

We provide two handshake modes: Discoverable Server and Hidden Server.
In both modes, the server does not need to keep any state during the handshake.

\subsection{Discoverable Server}
To establish a cryptographic session between a client and a discoverable server,
we base the cryptographic handshake on the Noise XX handshake
pattern~\cite{noise}. 
However, rather than using separate chains for the
protocol transcript and key derivation, SSTP incorporates duplex objects to
reduce the state machine to a single chain and authenticates the whole
transcript with tags.

\begin{figure}[ht]
\begin{subfigure}{0.47\columnwidth}
	\centering
	\includegraphics[width=1\columnwidth]{figures/crypto_handshake_discoverable.pdf}
	\caption{Discoverable Server}
	\label{fig:crypto_handshake_discoverable}
\end{subfigure}
\hspace{0.03\columnwidth}
\begin{subfigure}{0.47\columnwidth}
	\centering
	\includegraphics[width=1\columnwidth]{figures/crypto_handshake_hidden.pdf}
	\caption{Hidden Server}
	\label{fig:crypto_handshake_hidden}
\end{subfigure}
	\vspace{-5pt}
	\caption{\textbf{Session Establishment}---%
	\textnormal{}
	}
	\label{fig:crypto_handshake}
\end{figure}


\vspace{5pt} \textit{1) Client Hello:}\quad 
Initially, both the client and server are unauthenticated. The client begins by
sending a Client Hello to the server. The client creates an ephemeral key pair
($e_c^{priv}, e_c^{pub}$) and instantiates a duplex object. It absorbs the
protocol name (\tk), client hello message type (\texttt{0x1}), protocol version, reserved bytes, and the
client ephemeral public key into the duplex object, and squeezes out a message
authentication code (MAC). The client then begins the
session handshake by sending the message type, protocol version, client
ephemeral, and MAC to the server (Figure~\ref{fig:client_hello}). The client
will retry \tk number of times to account for lost handshake messages.

\input{bytefields/client_hello.tex}

\vspace{5pt} \textit{2) Server Hello:}\quad 
When the server receives the Client Hello, it instantiates a new duplex object, absorbing the protocol name, message type, protocol version, and
client ephemeral public key to verify the MAC
attached to the Client Hello. If the MAC matches, the server
replies with a Server Hello, otherwise it does not respond.

The server creates its own ephemeral key pair ($e_s^{priv}, e_s^{pub}$) and
performs a Diffie-Hellman between the client ephemeral and the server
ephemeral. The result of this Diffie-Hellman $
\texttt{DH}(e_s^{priv}, e_c^{pub} ) $ is used to key the duplex object, as only
the client and server have this shared secret. 
Continuing with the duplex object, the server absorbs the server hello message type (\texttt{0x2}), reserved bytes, server ephemeral public key, and the
Diffie-Hellman between the client and server ephemeral. The server also absorbs
a cookie that is sent as part of the server hello, which eliminates the need for
the server to store any state about client handshakes. 
The cookie construction is as follows: $\texttt{cookie} := \texttt{AEAD}(K_r,
e_s^{priv}, H(e_c^{pub}, \texttt{clientIP}, \texttt{clientPort})) $, where $K_r$
is a key known only to the server that is rotated every 2 minutes (or up to the
AEAD encryption limit), and $H$ is a cryptographic hash (e.g., SHA-256). The
cookie contains both the ciphertext and the authentication tag (32 + 16 bytes).
The cookie is absorbed into the duplex object and a MAC is squeezed out and
attached to the Server Hello (Figure~\ref{fig:server_hellp}). The server's
duplex object is then discarded.

\input{bytefields/server_hello.tex}

\vspace{5pt} \textit{3) Client Acknowledgment:}\quad 
When the client receives the Server Hello, it likewise computes the shared
secret $ \texttt{DH}(e_c^{priv}, e_s^{pub}) $ and absorbs the
server hello message type, reserved bytes, server ephemeral public key,
Diffie-Hellman result, and cookie into its existing duplex object. The client
then verifies the MAC with the squeezed output. If the MAC checks out, it
verifies that the owner of the $e_s$ key pair indeed sent the server hello
(otherwise the DH result would be different) and
has the same view of the handshake transcript thus far.

The third message of the handshake protocol is the client acknowledgment (Figure~\ref{fig:client_ack}). It includes the client acknowledgment message type (\texttt{0x3}), reserved bytes, and the client ephemeral public key. It
echoes the cookie back to the server and includes an encrypted SNI so that the
server knows which certificates to return to authenticate itself. The plaintext
SNI consists
of a 1 byte type indicator of the server ID (e.g., domain name, IoT serial
number) concatenated with a 255 byte server ID. The client continues with its
duplex object, absorbing the message type, reserved bytes, client ephemeral
public key, and cookie. It then encrypts the SNI with the state of the duplex
object.

\input{bytefields/client_ack.tex}

\vspace{5pt} \textit{4) Server Authentication:}\quad 
After receiving the Client Acknowledgment, the server AEAD decrypts the cookie using
a hash of the client ephemeral, IP address, and port as the associated data.
 Successful decryption ensures that the
cookie echoed back was originally encrypted by the server, indicating that the
client had previously sent a Client Hello without needing to keep state at the
server. Successful decryption of the cookie also verifies that the server is
talking to the same client that initiated the Client Hello and locks in the
client's ephemeral public key.

Given the Client Acknowledgment message, the server is able to resimulate the
duplex object up to this point, even without keeping state associated with the
initial Client Hello. The server instantiates a new duplex object and absorbs
all inputs in the order of the handshake messages prior (including the Client
Acknowledgment message) and squeezes out a MAC to verify the Client
Acknowledgment MAC. Using this MAC (which is dependent on the state of the
duplex object), the server decrypts the SNI and searches for the leaf
certificate and intermediate certificate to authenticate the server ID.
\todo{something about why there is just 1 intermediate}. Our PKI only uses a
single intermediate certificate to ensure that the entire Server Authentication
message fits into a single UDP packet.

At this point, both parties begin keeping session state, but still need to be
authenticated to each other.

To create the Server Authentication message, the server chooses a random unique 4 byte opaque string as the Session ID, and
absorbs the Server Authentication message type (\texttt{0x4}), reserved bytes,
and the Session ID. It encrypts the leaf and intermediate certificate from the
duplex construction and squeezes out the authentication tag. The server then
computes a Diffie-Hellman between the client ephemeral and the server static key
pair ($ \texttt{DH}(s_s^{priv}, e_c^{pub}) $), and absorbs the DH result. The MAC is squeezed out and attached to the
Server Authentication Message (Figure~\ref{fig:server_auth}).

\input{bytefields/server_auth.tex}

\vspace{5pt} \textit{5) Client Authentication:}\quad 
Upon receiving the Server Authentication message, the client absorbs the header
(the server authentication message type, reserved bytes, and Session ID), and
decrypts the certificates using the duplex material. It also computes and
absorbs the
Diffie-Hellman between the client ephemeral and the server static, and verifies
that the certificates are valid and the MAC is the same. This proves to the
client that the sender of the Server Authentication message indeed owns the
server static private key ($s_s^{priv}$) and that both parties have identical
views of the handshake transcript thus far.

The client then sends a Client Authentication message to authenticate itself to
the server. It absorbs the Client Authentication message type (\texttt{0x5}),
reserved bytes, and Session ID, and uses the duplex material to encrypt the
client static public key. The client static authentication tag is squeezed out.
The client then

\input{bytefields/client_auth.tex}


The SSTP discoverable server handshake completes after the client
authentication. At this point, the client and server share a secret session key
derived from the client ephemeral, server ephemeral, client static, and server
static, which provides \TODO{what}. Subsequent transport messages are sent
through one or more \emph{channels} within the encrypted session. We discuss
channels in Section~\ref{sec:channels}.


\subsection{Hidden Server}
We also support establishing sessions with hidden servers.

\subsection{Channel Multiplexing}
\label{sec:channels}


SSTP supports multiple channels within a single encrypted session. It borrows
and simplifies aspects of QUIC streams and TCP to implement a reliable stream
abstraction, but provides the option for unreliable data delivery within a
channel as well.

We show the format of an SSTP transport message in
Figure~\ref{fig:transport_message}. Channel multiplexing is implemented by
encapsulating a single \emph{channel frame} (green) within the Encrypted Data segment of
the transport message. Each channel is identified by the Channel ID in the frame
header. We statically allocate even-numbered channel IDs for client-initiated
channels and odd IDs for server-initiated channels to avoid collisions during
the channel creation process.
% note: QUIC actually does odd for client, even for server. 
Channels are created through a 2-way handshake when either the client
or server sends a Channel Initiation Request and the other party successfully
replies with a Channel Initiation Response. Channels are closed when both
parties send and receive a frame with the \texttt{FIN} bit set to one. Multiple
channels can be created and closed repeatedly without tearing down the entire
SSTP session.

\input{bytefields/transport_message.tex}

\subsection{Authentication and Encryption}
After the initial SSTP handshake messages, the payload (Encrypted Data) segment
of all SSTP transport messages are authenticated and encrypted. \todo{Wilson: more details}

\subsection{Channel Creation}

The channel creation 2-way handshake begins when one party (the initiator) sends
a message to the other (the responder) with the
\texttt{REQ} bit set to one and the Frame Number set to 0. This initial message
is the Channel Initiation Request. All initial handshake messages for a channel
must begin with Frame Number 0.
The Channel Initiation Request contains a non-negotiable Channel ID and Channel Type (reliable or
unreliable) chosen by the initiator, as well as the initiator's Receive Window
Size. If any of these values need to change during the lifetime of
the channel, the channel is closed and a new one is created. Additionally, any
initial data for the channel can be sent in the Data field.

Upon receipt of a Channel Initiation Request, the responder
replies with a Channel Initiation Response. Channel Initiation Responses have
the \texttt{RESP} bit set to 1 and Frame Number 0. 
% A frame cannot both be a request and a response. 
The responder chooses to accept or reject the
channel creation by setting the \texttt{ACC} bit to the appropriate value (1 for
accept, 0 for reject). The Channel ID and Channel Type are echoed back to the
initiator, and the responder sets its own Receive Window Size.

After both request and response frames have been received, the channel has been
created from the perspective of both the initiator and the responder. SSTP only
requires a 2-way handshake because all initial Frame Numbers start at 0.
Spoofing attacks caused by non-random initial sequence numbers are prevented
since the entire frame is authenticated and encrypted within the transport message.

Channel creation handshake messages do not use explicit acknowledgments, as the
response is implicitly an acknowledgment of the request. If the initiator does
not receive a Channel Initiation Response for some period of time after sending
a request, it will assume that the Channel was not
created and that either the request was lost or the response was lost. In either
case, it will retransmit a request. If the response was lost, the responder may
already be sending channel data since it assumes the channel has been created.
The initiator ignores all channel data and resends Channel Initiation Requests
until it properly receives a Channel Initiation Response. If the
responder receives a duplicate request, the newer request takes precedence and
all state from the previous half-channel is destroyed, and a new channel is
created from the new request.

\subsection{Reliable Channels}
We use Frame Numbers and Acknowledgment Numbers for a simple implementation of
reliable transmission based on TCP. We consider congestion control to be
orthogonal to reliable transmission within a channel and leave it to future
work. 

The Frame Number is a 32-bit sequence number starting at 0 that counts
individual frames. Channel handshake messages always have Frame Number
0, and data always starts at Frame Number 1. In the
event that the Frame Number reaches the maximum value of $2^{32} - 1$, it will
wraparound back to 0, with \texttt{REQ} and \texttt{RESP} flags unset so as to
not interpret data messages as a new handshake message. Frame Numbers also
encode the order of the application data for stream reassembly at the receiver.

When an SSTP message is sent, a retransmission timer is started to recover from
loss in the network. If the message is received, the responder will reply with an acknowledgment for the next Frame Number
expected. Every data message will contain an Acknowledgment Number. This 32-bit Acknowledgment Number replaces the 32-bits of Window Size,
Channel Type, and Reserved fields that are only used during channel creation,
which saves 4 bytes of control data in every message. If no acknowledgment is
received before the retransmission timer expires, the frame is resent. 

\subsection{Unreliable Channels}
For unreliable channels, both client and server can begin
sending data to each other without needing to check proper receival or ordering
of frames.
However, unlike vanilla UDP, this is not a connectionless communication mode.
Both a session and a channel need to be created beforehand, and all frames are
authenticated and encrypted by virtue of being encapsulated in an SSTP transport
message. Both the Frame Number and the Acknowledgment Number fields can be ignored.

\subsection{Channel Tear Down}
To close a channel, we use the four-way \texttt{FIN-ACK/FIN-ACK} handshake
common in most TCP implementations. If channel frames are received by an
endpoint after a
\texttt{FIN} has been sent, the endpoint will continue sending acknowledgments
with the \texttt{FIN} flag sent to signal closing the channel. Once both
endpoints have received acknowledgments for both \texttt{FIN}s, the channel is
closed and the Channel ID can be reused within the SSTP session.
% We do not need RST flag. In TCP this is usually used when a segment arrives
% that is not intended for the current connection, but since all frames are
% authenticated this won't occur















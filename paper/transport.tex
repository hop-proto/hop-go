\section{Transport Protocol}

\subsection{Session Establishment}

On a successful handshake, the client and server have established a shared
cryptographic session over which they can communicate through encrypted
channels indefinitely (?), even in the case of loss of connectivity or IP address migration.

There are two handshake modes: Discoverable Server and Hidden Server. If a
server is discoverable, it will respond to all attempted handshakes, revealing
its presence as an SSTP server. In hidden server mode, it will only respond to
authenticated client requests, and otherwise will not respond.
In both modes, the server does not need to keep any state during the handshake.

\TODO{what to do when handshake messages are lost? David might be implementing
this already?}

\subsection{Discoverable Server}


\begin{figure}[ht]
\begin{subfigure}{0.47\columnwidth}
	\centering
	\includegraphics[width=1\columnwidth]{figures/crypto_handshake_discoverable.pdf}
	\caption{Discoverable Server}
	\label{fig:crypto_handshake_discoverable}
\end{subfigure}
\hspace{0.03\columnwidth}
\begin{subfigure}{0.47\columnwidth}
	\centering
	\includegraphics[width=1\columnwidth]{figures/crypto_handshake_hidden.pdf}
	\caption{Hidden Server}
	\label{fig:crypto_handshake_hidden}
\end{subfigure}
	\vspace{-5pt}
	\caption{\textbf{Session Establishment}---%
	\textnormal{}
	}
	\label{fig:crypto_handshake}
\end{figure}


\vspace{5pt} \noindent\textit{1) Client Hello:}\quad 
At first, both the client and server are unauthenticated. The server is
publically discoverable and has a
list of authorized clients that it is willing to establish a session with.
The client initiates the handshake by sending a Client Hello message to the
server. This message is sent in plaintext, and contains the Client Hello message
type (0x1), SSTP version, client ephemeral public key, and a MAC (Figure~\ref{fig:client_hello}).
The client keeps state for its own view of the handshake transcript using a
duplex object that it maintains throughout the handshake duration. In sequence,
the client absorbs the protocol name (\tk), message type,
version, reserved bytes, and client ephemeral public key into the duplex
object, and squeezes out a MAC keyed using the absorbed duplex material. This
MAC only provides integrity for the Client Hello, as it is not keyed 
using any private data. To account for lost Client Hellos, the client
will retry \tk number of times after a time-out of \tk waiting for the server response.

\input{bytefields/client_hello.tex}

When the server receives a Client Hello, it instantiates a new duplex
object that represents the server's view of the handshake transcript thus far.
Mirroring the client, the server absorbs the protocol name, message type,
protocol version, and client ephemeral public key into its own duplex object and
verifies that the MAC attached to the Client Hello matches. If this verification
is successful, the server can confirm that it is speaking the same protocol and its view of the handshake (up to the
Client Hello) is identical to that of the client. The server then replies with a
Server Hello. Otherwise, it does not respond. We note that in
discoverable mode, the server will still respond to connection attempts from
unauthenticated clients. \todo{is this a problem for computational/memory DoS
attacks? seems like a lot less computation and state than TLS handshakes, so I
guess that's good}

\vspace{5pt} \noindent\textit{2) Server Hello:}\quad 
The server creates its own DH ephemeral key pair and
performs a Diffie-Hellman calculation between the client ephemeral and its own
server ephemeral. The DH result 
%$\texttt{DH}(e_s^{priv}, e_c^{pub} ) $
is used to key the duplex object, as only
the client and server will share this secret. 
Continuing with its duplex object, the server absorbs the server hello message type (0x2), reserved bytes, server ephemeral public key, and the
DH result between the client and server ephemerals. The server also sends a
cookie that encrypts its ephemeral private key with associated client data in
the Server Hello message. This cookie eliminates the need for the server to
store state about incomplete (partial?) client handshakes. 
The cookie construction is as follows: $\texttt{cookie} := \texttt{AEAD}(K_r,
e_s^{priv}, H(e_c^{pub}, \texttt{clientIP}, \texttt{clientPort})) $, where $K_r$
is a key known only to the server that is rotated every 2 minutes (or up to the
AEAD encryption limit), and $H$ is a cryptographic hash (e.g., SHA-256). The
cookie contains both the ciphertext and the authentication tag (32 + 16 bytes).
The cookie is absorbed into the duplex object and a MAC is squeezed out and
attached to the Server Hello (Figure~\ref{fig:server_hello}). The server's
duplex object is then discarded, eliminating all state associated with the handshake.

\input{bytefields/server_hello.tex}

When the client receives the Server Hello, it likewise computes the shared
DH secret using the server ephemeral public key and absorbs the
server hello message type, reserved bytes, server ephemeral public key,
Diffie-Hellman result, and cookie into its existing duplex object. The client
then verifies the MAC with the squeezed output. At this stage of the handshake,
the duplex object is keyed using the shared DH secret. If the computed MAC
matches the one provided in the Server Hello, it
verifies to the client that the owner of the $e_s$ key pair indeed sent the
Server Hello and has an identical view of the handshake transcript thus far.

\vspace{5pt} \noindent\textit{3) Client Acknowledgment:}\quad 
After verification of the Server Hello MAC, the client sends a Client
Acknowledgment message. In this message, the client specifies the server ID it
wishes to connect to in the encrypted SNI field (Figure~\ref{fig:client_ack}).
The plaintext SNI consists of a 1 byte type indicator for the server ID (e.g.,
domain name, IoT serial number) concatenated with a 255 byte server ID. The
client continues with its duplex object and absorbs the Client Ack message type
(0x3), reserved bytes, client ephemeral public key, and the cookie. 
The SNI is encrypted using
the state of the entire duplex object thus far. (\todo{cite something here? Not
sure how the encryption with duplex material works}). The client also resends
its ephemeral public key in the Client Acknowledgment message and echoes the
cookie back to the server so the server can reconstruct the handshake
transcript. Like in all
messages, a MAC is squeezed from the client's duplex object and attached to the
Client Acknowledgment message.


\input{bytefields/client_ack.tex}

At this point, the server has no state associated with the ongoing handshake. After receiving the Client Acknowledgment, the server decrypts the cookie
using a hash of the provided client ephemeral, IP address, and port as the
associated data. Successful decryption ensures that the cookie echoed back was
originally encrypted by the server, and indicates that the client
had previously sent a Client Hello with the same client ephemeral. The server
retrieves its ephemeral private key associated with the session from the
decrypted cookie. Now, the server has all the data required to resimulate the
duplex. The server instantiates a new duplex object, absorbs
all prior handshake data according to protocol (including the fields in the
Client Acknowledgment message), and squeezes out a MAC to verify the Client
Acknowledgment MAC.
Successful verification proves that the owner of the $e_c$ key pair indeed sent
the Client Hello and Client Acknowledgment and has the same view of the
transcript thus far.


\vspace{5pt} \noindent\textit{4) Server Authentication:}\quad 
Using the state of the duplex, which should be identical to that of the
client's, the server decrypts the SNI. It searches for the leaf certificate and intermediate certificate to authenticate the server ID.
\todo{something about why there is just 1 intermediate}. Our PKI only uses a
single intermediate certificate to ensure that the entire Server Authentication
message fits into a single UDP packet.

At this stage, both parties begin keeping session state, but are not yet
authenticated to each other.

Continuing from the duplex prior, the server
absorbs the Server Authentication message type ({0x4}), reserved bytes,
and the Session ID, which is a random 4 byte opaque string chosen by the server.
It encrypts the leaf and intermediate certificate using the current
duplex state and squeezes out the certificate authentication tag. The server
then performs a Diffie-Hellman calculation between the client ephemeral and the
server static key pair ($ \texttt{DH}(s_s^{priv}, e_c^{pub}) $), and absorbs the
DH result. The MAC is squeezed out and attached to the
Server Authentication Message (Figure~\ref{fig:server_auth}).

\input{bytefields/server_auth.tex}

Upon receiving the Server Authentication message, the client absorbs the header
(the message type, reserved bytes, and Session ID), and
decrypts the certificates using the duplex material. It also the DH result between the client ephemeral and the server static,
and verifies that the certificates are valid and the MAC is the same. This
proves to the client that sender of the Server Authentication message owns the
server static private key ($s_s^{priv}$) (the server is who it says it is) and
that it is the actual owner of the Server ID. It also verifies that the
handshake transcript is identical.

\vspace{5pt} \noindent\textit{5) Client Authentication:}\quad 
The client then sends a Client Authentication message (Figure~\ref{fig:client_auth}) to authenticate itself to
the server. It absorbs the Client Authentication message type ({0x5}),
reserved bytes, and Session ID. Using the current duplex state, it
encrypts its static public key and squeezes out the client static authentication tag.
The client then absorbs the Diffie-Hellman between the client static and the
server ephemeral ($ \texttt{DH}(s_c^{priv}, e_s^{pub}) $), and squeezes out the
Client Authentication MAC.

\input{bytefields/client_auth.tex}

When the server receives the Client Authentication Message, it absorbs the
message type, reserved bytes, and Session ID, then decrypts the client static
public key using the duplex and the client static authentication tag. 
The server  checks to see if the client static public key is that of a valid
client (i.e., in the list of authorized keys), and if not drops the session and
destroys all state. It then absorbs the Diffie-Hellman between the client static
and server ephemeral, and verifies that the squeezed out MAC matches. This
confirms that both parties have identical
views of the entire session handshake. The SSTP discoverable server handshake
completes after the client authentication message is verified by the server. 

\vspace{5pt} \noindent\textbf{Key Derivation}\quad 
If the handshake is successful, the client and server share a secret
derived from the client ephemeral, server ephemeral, client static, and server
static, and have identical duplex objects keyed using each of these key pairs. We use the duplex object to derive two encryption keys: one for
client-to-server transport messages and one for server-to-client transport
messages. Both client and server perform the following psuedocode:


\begin{itemize}
	\item duplex.ratchet()
	\item duplex.absorb("client\_to\_server\_key")
	\item \texttt{client\_to\_server\_key} = duplex.squeeze\_key()
	\item duplex.ratchet()
	\item duplex.absorb("server\_to\_client\_key")
	\item \texttt{server\_to\_client\_key} = duplex.squeeze\_key()
\end{itemize}
Subsequent transport messages are encrypted using these shared session keys,
which rotate every $2^{64}$ messages (\todo{does this mean ratchet again?}).
Transport messages are sent through one or more \emph{channels} within the
session, which are discussed in Section~\ref{sec:channels}. 


\subsection{Hidden Server}
We also support establishing sessions with hidden servers.

\subsection{Channel Multiplexing}
\label{sec:channels}


SSTP supports multiple channels within a single encrypted session. It borrows
and simplifies aspects of QUIC streams and TCP to implement a reliable stream
abstraction, but provides the option for unreliable data delivery within a
channel as well.

We show the format of an SSTP transport message in
Figure~\ref{fig:transport_message}. Channel multiplexing is implemented by
encapsulating a single \emph{channel frame} (green) within the Encrypted Data segment of
the transport message. Each channel is identified by the Channel ID in the frame
header. We statically allocate even-numbered channel IDs for client-initiated
channels and odd IDs for server-initiated channels to avoid collisions during
the channel creation process.
% note: QUIC actually does odd for client, even for server. 
Channels are created through a 2-way handshake when either the client
or server sends a Channel Initiation Request and the other party successfully
replies with a Channel Initiation Response. Channels are closed when both
parties send and receive a frame with the \texttt{FIN} bit set to one. Multiple
channels can be created and closed repeatedly without tearing down the entire
SSTP session.

\input{bytefields/transport_message.tex}

\subsection{Authentication and Encryption}
After the initial SSTP handshake messages, the payload (Encrypted Data) segment
of all SSTP transport messages are authenticated and encrypted. \todo{Wilson: more details}

\subsection{Channel Creation}

The channel creation 2-way handshake begins when one party (the initiator) sends
a message to the other (the responder) with the
\texttt{REQ} bit set to one and the Frame Number set to 0. This initial message
is the Channel Initiation Request. All initial handshake messages for a channel
must begin with Frame Number 0.
The Channel Initiation Request contains a non-negotiable Channel ID and Channel Type (reliable or
unreliable) chosen by the initiator, as well as the initiator's Receive Window
Size. If any of these values need to change during the lifetime of
the channel, the channel is closed and a new one is created. Additionally, any
initial data for the channel can be sent in the Data field.

Upon receipt of a Channel Initiation Request, the responder
replies with a Channel Initiation Response. Channel Initiation Responses have
the \texttt{RESP} bit set to 1 and Frame Number 0. 
% A frame cannot both be a request and a response. 
The responder chooses to accept or reject the
channel creation by setting the \texttt{ACC} bit to the appropriate value (1 for
accept, 0 for reject). The Channel ID and Channel Type are echoed back to the
initiator, and the responder sets its own Receive Window Size.

After both request and response frames have been received, the channel has been
created from the perspective of both the initiator and the responder. SSTP only
requires a 2-way handshake because all initial Frame Numbers start at 0.
Spoofing attacks caused by non-random initial sequence numbers are prevented
since the entire frame is authenticated and encrypted within the transport message.

Channel creation handshake messages do not use explicit acknowledgments, as the
response is implicitly an acknowledgment of the request. If the initiator does
not receive a Channel Initiation Response for some period of time after sending
a request, it will assume that the Channel was not
created and that either the request was lost or the response was lost. In either
case, it will retransmit a request. If the response was lost, the responder may
already be sending channel data since it assumes the channel has been created.
The initiator ignores all channel data and resends Channel Initiation Requests
until it properly receives a Channel Initiation Response. If the
responder receives a duplicate request, the newer request takes precedence and
all state from the previous half-channel is destroyed, and a new channel is
created from the new request.

\subsection{Reliable Channels}
We use Frame Numbers and Acknowledgment Numbers for a simple implementation of
reliable transmission based on TCP. We consider congestion control to be
orthogonal to reliable transmission within a channel and leave it to future
work. 

The Frame Number is a 32-bit sequence number starting at 0 that counts
individual frames. Channel handshake messages always have Frame Number
0, and data always starts at Frame Number 1. In the
event that the Frame Number reaches the maximum value of $2^{32} - 1$, it will
wraparound back to 0, with \texttt{REQ} and \texttt{RESP} flags unset so as to
not interpret data messages as a new handshake message. Frame Numbers also
encode the order of the application data for stream reassembly at the receiver.

When an SSTP message is sent, a retransmission timer is started to recover from
loss in the network. If the message is received, the responder will reply with an acknowledgment for the next Frame Number
expected. Every data message will contain an Acknowledgment Number. This 32-bit Acknowledgment Number replaces the 32-bits of Window Size,
Channel Type, and Reserved fields that are only used during channel creation,
which saves 4 bytes of control data in every message. If no acknowledgment is
received before the retransmission timer expires, the frame is resent. 

\subsection{Unreliable Channels}
For unreliable channels, both client and server can begin
sending data to each other without needing to check proper receival or ordering
of frames.
However, unlike vanilla UDP, this is not a connectionless communication mode.
Both a session and a channel need to be created beforehand, and all frames are
authenticated and encrypted by virtue of being encapsulated in an SSTP transport
message. Both the Frame Number and the Acknowledgment Number fields can be ignored.

\subsection{Channel Tear Down}
To close a channel, we use the four-way \texttt{FIN-ACK/FIN-ACK} handshake
common in most TCP implementations. If channel frames are received by an
endpoint after a
\texttt{FIN} has been sent, the endpoint will continue sending acknowledgments
with the \texttt{FIN} flag sent to signal closing the channel. Once both
endpoints have received acknowledgments for both \texttt{FIN}s, the channel is
closed and the Channel ID can be reused within the SSTP session.
% We do not need RST flag. In TCP this is usually used when a segment arrives
% that is not intended for the current connection, but since all frames are
% authenticated this won't occur















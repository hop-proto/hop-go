// Code generated by gen_config.go. DO NOT EDIT.
package config

import (
	"fmt"
	"strconv"

	"github.com/sirupsen/logrus"
	"hop.computer/hop/config/ast"
)

func identity(s string) (string, error) {
	return s, nil
}

func bs(s string) (BoolSetting, error) {
	b, err := strconv.ParseBool(s)
	if err != nil {
		return Unset, err
	}
	if b {
		return True, nil
	}
	return False, nil
}

func loadClientConfig_Gen(c *ClientConfig, root *ast.Node) (*ClientConfig, error) {
	var bc *HostConfig
	err := root.Walk(func(n ast.Node) error {
		global := false
		if n.Parent == nil {
			global = true
		} else if n.Parent != nil && n.Parent.Type == ast.NodeTypeFile {
			global = true
		}
		switch n.Type {
		case ast.NodeTypeFile:
		case ast.NodeTypeBlock:
			switch n.BlockType {
			case "Include":
				logrus.Warnf("%q not yet implemented and %q will be ignored", "Include", n.BlockName)
			case "Host":
				c.Hosts = append(c.Hosts, HostConfig{})
				bc = &c.Hosts[len(c.Hosts)-1]
				bc.Pattern = n.BlockName
			}
		case ast.NodeTypeSetting:
			if global {
				switch n.SettingKey {
				case ast.Setting.CAFile.Value:
					result, err := identity(n.SettingValue)
					if err != nil {
						return err
					}
					c.CAFiles = append(c.CAFiles, result)
				case ast.Setting.Key.Value:
					result, err := identity(n.SettingValue)
					if err != nil {
						return err
					}
					c.Key = result
				case ast.Setting.Certificate.Value:
					result, err := identity(n.SettingValue)
					if err != nil {
						return err
					}
					c.Certificate = result
				case ast.Setting.AutoSelfSign.Value:
					result, err := bs(n.SettingValue)
					if err != nil {
						return err
					}
					c.AutoSelfSign = result
				case ast.Setting.AgentURL.Value:
					result, err := identity(n.SettingValue)
					if err != nil {
						return err
					}
					c.AgentURL = result
				default:
					logrus.Warnf("unknown global setting %q", n.SettingKey)
				}
			} else {
				switch n.SettingKey {
				case ast.Setting.Address.Value:
					result, err := identity(n.SettingValue)
					if err != nil {
						return err
					}
					bc.Hostname = result
				case ast.Setting.User.Value:
					result, err := identity(n.SettingValue)
					if err != nil {
						return err
					}
					bc.User = result
				case ast.Setting.Port.Value:
					result, err := strconv.Atoi(n.SettingValue)
					if err != nil {
						return err
					}
					bc.Port = result
				case ast.Setting.AutoSelfSign.Value:
					result, err := bs(n.SettingValue)
					if err != nil {
						return err
					}
					bc.AutoSelfSign = result
				case ast.Setting.Key.Value:
					result, err := identity(n.SettingValue)
					if err != nil {
						return err
					}
					bc.Key = result
				case ast.Setting.Certificate.Value:
					result, err := identity(n.SettingValue)
					if err != nil {
						return err
					}
					bc.Certificate = result
				default:
					logrus.Warnf("unknown block setting %q", n.SettingKey)
				}
			}
		default:
			return fmt.Errorf("unknown node type %s", n.Type)
		}
		return nil
	})
	return c, err
}

func loadServerConfig_Gen(c *ServerConfig, root *ast.Node) (*ServerConfig, error) {
	var bc *NameConfig
	err := root.Walk(func(n ast.Node) error {
		global := false
		if n.Parent == nil {
			global = true
		} else if n.Parent != nil && n.Parent.Type == ast.NodeTypeFile {
			global = true
		}
		switch n.Type {
		case ast.NodeTypeFile:
		case ast.NodeTypeBlock:
			switch n.BlockType {
			case "Include":
				logrus.Warnf("%q not yet implemented and %q will be ignored", "Include", n.BlockName)
			case "Name":
				c.Names = append(c.Names, NameConfig{})
				bc = &c.Names[len(c.Names)-1]
				bc.Pattern = n.BlockName
			}
		case ast.NodeTypeSetting:
			if global {
				switch n.SettingKey {
				case ast.Setting.Key.Value:
					result, err := identity(n.SettingValue)
					if err != nil {
						return err
					}
					c.Key = result
				case ast.Setting.Certificate.Value:
					result, err := identity(n.SettingValue)
					if err != nil {
						return err
					}
					c.Certificate = result
				case ast.Setting.Intermediate.Value:
					result, err := identity(n.SettingValue)
					if err != nil {
						return err
					}
					c.Intermediate = result
				case ast.Setting.ListenAddress.Value:
					result, err := identity(n.SettingValue)
					if err != nil {
						return err
					}
					c.ListenAddress = result
				case ast.Setting.AutoSelfSign.Value:
					result, err := bs(n.SettingValue)
					if err != nil {
						return err
					}
					c.AutoSelfSign = result
				default:
					logrus.Warnf("unknown global setting %q", n.SettingKey)
				}
			} else {
				switch n.SettingKey {
				case ast.Setting.Key.Value:
					result, err := identity(n.SettingValue)
					if err != nil {
						return err
					}
					bc.Key = result
				case ast.Setting.Certificate.Value:
					result, err := identity(n.SettingValue)
					if err != nil {
						return err
					}
					bc.Certificate = result
				case ast.Setting.Intermediate.Value:
					result, err := identity(n.SettingValue)
					if err != nil {
						return err
					}
					bc.Intermediate = result
				case ast.Setting.AutoSelfSign.Value:
					result, err := bs(n.SettingValue)
					if err != nil {
						return err
					}
					bc.AutoSelfSign = result
				default:
					logrus.Warnf("unknown block setting %q", n.SettingKey)
				}
			}
		default:
			return fmt.Errorf("unknown node type %s", n.Type)
		}
		return nil
	})
	return c, err
}

package main

import (
	"bytes"
	"flag"
	"go/format"
	"io"
	"os"
	"text/template"

	"github.com/sirupsen/logrus"
)

// SettingMapper maps a setting name to a field name in the config struct
type SettingMapper struct {
	Setting   string // name in config
	Field     string // name in struct
	Append    bool   // true if Field is an array
	Converter string // name of f(string) -> typeof(Field)
}

// ConfigMapper holds which settings are global and host specific
type ConfigMapper struct {
	GlobalSettings []SettingMapper
	BlockSettings  []SettingMapper
}

var converters = struct {
	Identity string
	Bool     string
	Int      string
}{
	Identity: "identity",
	Bool:     "bs",
	Int:      "strconv.Atoi",
}

var clientMapper = ConfigMapper{
	GlobalSettings: []SettingMapper{
		{
			Setting:   "CAFile",
			Field:     "CAFiles",
			Converter: converters.Identity,
			Append:    true,
		},
		{
			Setting:   "Key",
			Field:     "Key",
			Converter: converters.Identity,
		},
		{
			Setting:   "Certificate",
			Field:     "Certificate",
			Converter: converters.Identity,
		},
		{
			Setting:   "AutoSelfSign",
			Field:     "AutoSelfSign",
			Converter: converters.Bool,
		},
	},
	BlockSettings: []SettingMapper{
		{
			Setting:   "Address",
			Field:     "Hostname",
			Converter: converters.Identity,
		},
		{
			Setting:   "Port",
			Field:     "Port",
			Converter: converters.Int,
		},
		{
			Setting:   "AutoSelfSign",
			Field:     "AutoSelfSign",
			Converter: converters.Bool,
		},
		{
			Setting:   "Key",
			Field:     "Key",
			Converter: converters.Identity,
		},
		{
			Setting:   "Certificate",
			Field:     "Certificate",
			Converter: converters.Identity,
		},
	},
}

var tmpl = `// Code generated by gen_config.go. DO NOT EDIT.
package config

import (
	"fmt"
	"strconv"

	"github.com/sirupsen/logrus"
	"zmap.io/portal/config/ast"
)

func identity(s string) (string, error) {
	return s, nil
}

func bs(s string) (BoolSetting, error) {
	b, err := strconv.ParseBool(s)
	if err != nil {
		return Unset, err
	}
	if b {
		return True, nil
	}
	return False, nil
}

func loadClientConfig_Gen(c *ClientConfig, root *ast.Node) (*ClientConfig, error) {
	var hc *HostConfig
	err := root.Walk(func(n ast.Node) error {
		global := false
		if n.Parent == nil {
			global = true
		} else if n.Parent != nil && n.Parent.Type == ast.NodeTypeFile {
			global = true
		}
		switch n.Type {
		case ast.NodeTypeFile:
		case ast.NodeTypeBlock:
			switch n.BlockType {
			case "Include":
				logrus.Warnf("%q not yet implemented and %q will be ignored", "Include", n.BlockName)
			case "Host":
				c.Hosts = append(c.Hosts, HostConfig{})
				hc = &c.Hosts[len(c.Hosts)-1]
				hc.Pattern = n.BlockName
			}
		case ast.NodeTypeSetting:
			if global {
				switch n.SettingKey {
					{{- range .GlobalSettings }}
				case ast.Setting.{{ .Setting }}.Value:
					result, err := {{ .Converter }}(n.SettingValue)
					if err != nil {
						return err
					}
					{{- if .Append }}
					c.{{ .Field }} = append(c.{{ .Field }}, result)
					{{- else }}
					c.{{ .Field }} = result
					{{- end }}
					{{- end }}
				default:
					logrus.Warnf("unknown global setting %q", n.SettingKey)
				}
			} else {
				switch n.SettingKey {
					{{- range .BlockSettings }}
				case ast.Setting.{{ .Setting }}.Value:
					result, err := {{ .Converter }}(n.SettingValue)
					if err != nil {
						return err
					}
					{{- if .Append }}
					hc.{{ .Field }} = append(c.{{ .Field }}, result)
					{{- else }}
					hc.{{ .Field }} = result
					{{- end }}
					{{- end }}
				}
			}
		default:
			return fmt.Errorf("unknown node type %s", n.Type)
		}
		return nil
	})
	return c, err
}

`

var noFormat bool

func main() {
	flag.BoolVar(&noFormat, "no-format", false, "skip formatting")
	flag.Parse()

	var f io.Writer
	if path := flag.Arg(0); path != "" {
		fd, err := os.Create(path)
		if err != nil {
			logrus.Fatalf("unable to open output file %q: %s", path, err)
		}
		f = fd
	} else {
		f = os.Stdout
	}

	t := template.New("config")
	_, err := t.Parse(tmpl)
	if err != nil {
		logrus.Fatalf("unable to parse template: %s", err)
	}
	buf := bytes.Buffer{}
	data := &clientMapper
	err = t.Execute(&buf, data)
	if err != nil {
		logrus.Fatalf("unable to execute template: %s", err)
	}
	if noFormat {
		io.Copy(f, &buf)
		return
	}
	out, err := format.Source(buf.Bytes())
	if err != nil {
		logrus.Fatalf("unable to format source: %s", err)
	}
	f.Write(out)
}

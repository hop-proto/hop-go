package main

import (
	"bytes"
	"flag"
	"go/format"
	"io"
	"os"
	"text/template"

	"github.com/sirupsen/logrus"
)

// ConfigType wrapes a ConfigMapper with type names for Client and Server types
type ConfigType struct {
	Name            string // Config type name
	BlockType       string // Returned by AST
	Blocks          string // Field name of the array of ConfigBlockType
	ConfigBlockType string
	ConfigMapper
}

// SettingMapper maps a setting name to a field name in the config struct
type SettingMapper struct {
	Setting   string // name in config
	Field     string // name in struct
	Append    bool   // true if Field is an array
	Converter string // name of f(string) -> typeof(Field)
}

// ConfigMapper holds which settings are global and host specific
type ConfigMapper struct {
	GlobalSettings []SettingMapper
	BlockSettings  []SettingMapper
}

var converters = struct {
	Identity string
	Bool     string
	Int      string
}{
	Identity: "identity",
	Bool:     "bs",
	Int:      "strconv.Atoi",
}

var clientMapper = ConfigMapper{
	GlobalSettings: []SettingMapper{
		{
			Setting:   "CAFile",
			Field:     "CAFiles",
			Converter: converters.Identity,
			Append:    true,
		},
		{
			Setting:   "Key",
			Field:     "Key",
			Converter: converters.Identity,
		},
		{
			Setting:   "Certificate",
			Field:     "Certificate",
			Converter: converters.Identity,
		},
		{
			Setting:   "AutoSelfSign",
			Field:     "AutoSelfSign",
			Converter: converters.Bool,
		},
		{
			Setting:   "AgentURL",
			Field:     "AgentURL",
			Converter: converters.Identity,
		},
	},
	BlockSettings: []SettingMapper{
		{
			Setting:   "Address",
			Field:     "Hostname",
			Converter: converters.Identity,
		},
		{
			Setting:   "Port",
			Field:     "Port",
			Converter: converters.Int,
		},
		{
			Setting:   "AutoSelfSign",
			Field:     "AutoSelfSign",
			Converter: converters.Bool,
		},
		{
			Setting:   "Key",
			Field:     "Key",
			Converter: converters.Identity,
		},
		{
			Setting:   "Certificate",
			Field:     "Certificate",
			Converter: converters.Identity,
		},
	},
}

var serverMapper = ConfigMapper{
	GlobalSettings: []SettingMapper{
		{
			Setting:   "Key",
			Field:     "Key",
			Converter: converters.Identity,
		},
		{
			Setting:   "Certificate",
			Field:     "Certificate",
			Converter: converters.Identity,
		},
		{
			Setting:   "Intermediate",
			Field:     "Intermediate",
			Converter: converters.Identity,
		},
		{
			Setting:   "ListenAddress",
			Field:     "ListenAddress",
			Converter: converters.Identity,
		},
		{
			Setting:   "AutoSelfSign",
			Field:     "AutoSelfSign",
			Converter: converters.Bool,
		},
	},
	BlockSettings: []SettingMapper{
		{
			Setting:   "Key",
			Field:     "Key",
			Converter: converters.Identity,
		},
		{
			Setting:   "Certificate",
			Field:     "Certificate",
			Converter: converters.Identity,
		},
		{
			Setting:   "Intermediate",
			Field:     "Intermediate",
			Converter: converters.Identity,
		},
		{
			Setting:   "AutoSelfSign",
			Field:     "AutoSelfSign",
			Converter: converters.Bool,
		},
	},
}

var tmpl = `// Code generated by gen_config.go. DO NOT EDIT.
package config

import (
	"fmt"
	"strconv"

	"github.com/sirupsen/logrus"
	"hop.computer/hop/config/ast"
)

func identity(s string) (string, error) {
	return s, nil
}

func bs(s string) (BoolSetting, error) {
	b, err := strconv.ParseBool(s)
	if err != nil {
		return Unset, err
	}
	if b {
		return True, nil
	}
	return False, nil
}

{{ range .Types }}
func load{{ .Name }}_Gen(c *{{ .Name }}, root *ast.Node) (*{{ .Name }}, error) {
	var bc *{{ .ConfigBlockType}}
	err := root.Walk(func(n ast.Node) error {
		global := false
		if n.Parent == nil {
			global = true
		} else if n.Parent != nil && n.Parent.Type == ast.NodeTypeFile {
			global = true
		}
		switch n.Type {
		case ast.NodeTypeFile:
		case ast.NodeTypeBlock:
			switch n.BlockType {
			case "Include":
				logrus.Warnf("%q not yet implemented and %q will be ignored", "Include", n.BlockName)
			case {{ printf "%q" .BlockType }}:
				c.{{ .Blocks }} = append(c.{{ .Blocks }}, {{ .ConfigBlockType }}{})
				bc = &c.{{ .Blocks }}[len(c.{{ .Blocks }})-1]
				bc.Pattern = n.BlockName
			}
		case ast.NodeTypeSetting:
			if global {
				switch n.SettingKey {
					{{- range .GlobalSettings }}
				case ast.Setting.{{ .Setting }}.Value:
					result, err := {{ .Converter }}(n.SettingValue)
					if err != nil {
						return err
					}
					{{- if .Append }}
					c.{{ .Field }} = append(c.{{ .Field }}, result)
					{{- else }}
					c.{{ .Field }} = result
					{{- end }}
					{{- end }}
				default:
					logrus.Warnf("unknown global setting %q", n.SettingKey)
				}
			} else {
				switch n.SettingKey {
					{{- range .BlockSettings }}
				case ast.Setting.{{ .Setting }}.Value:
					result, err := {{ .Converter }}(n.SettingValue)
					if err != nil {
						return err
					}
					{{- if .Append }}
					bc.{{ .Field }} = append(c.{{ .Field }}, result)
					{{- else }}
					bc.{{ .Field }} = result
					{{- end }}
					{{- end }}
				default:
					logrus.Warnf("unknown block setting %q", n.SettingKey)
				}
			}
		default:
			return fmt.Errorf("unknown node type %s", n.Type)
		}
		return nil
	})
	return c, err
}

{{ end }}

`

var noFormat bool

func main() {
	flag.BoolVar(&noFormat, "no-format", false, "skip formatting")
	flag.Parse()

	var f io.Writer
	if path := flag.Arg(0); path != "" {
		fd, err := os.Create(path)
		if err != nil {
			logrus.Fatalf("unable to open output file %q: %s", path, err)
		}
		f = fd
	} else {
		f = os.Stdout
	}

	t := template.New("config")
	_, err := t.Parse(tmpl)
	if err != nil {
		logrus.Fatalf("unable to parse template: %s", err)
	}
	buf := bytes.Buffer{}
	data := struct {
		Types []ConfigType
	}{
		Types: []ConfigType{
			{
				Name:            "ClientConfig",
				BlockType:       "Host",
				Blocks:          "Hosts",
				ConfigBlockType: "HostConfig",
				ConfigMapper:    clientMapper,
			},
			{
				Name:            "ServerConfig",
				BlockType:       "Name",
				Blocks:          "Names",
				ConfigBlockType: "NameConfig",
				ConfigMapper:    serverMapper,
			},
		},
	}
	err = t.Execute(&buf, data)
	if err != nil {
		logrus.Fatalf("unable to execute template: %s", err)
	}
	if noFormat {
		io.Copy(f, &buf)
		return
	}
	out, err := format.Source(buf.Bytes())
	if err != nil {
		logrus.Fatalf("unable to format source: %s", err)
	}
	f.Write(out)
}

Architecture
============

Documentation of the code and types themselves should be primarily done in
comments following Golang conventions. This document explains what's here and
where to go looking for specific thing.

## Components

This repository contains:
* Implementations of the [Cyclist][cyclist] and [Kravatte][kravatte]
  cryptographic primitives.
* The **Hop Transport Layer**, which uses the cryptographic primitives.
* The **Hop Tubes Layer**, implemented on top of the Hop Transport layer.
* The **Hop Remote Access** application, an SSH replacement, built on top of the Hop Tubes layer.
* Associated **command-line tools**.
* Build and test tooling.

### Cryptography

Hop uses the [Cyclist][cyclist] construction with the core Keccak (SHA3)
permutation during the handshake. Post-handshake, Hop uses the
[Kravatte][kravatte] AEAD.

See the `cyclist`, `kravatte`, `keys`, and `snp` packages.

### Transport Layer

The transport layer implements a `net.Conn`-like interface. Unlike Conn or
UDPConn, the transport layer is unordered, but still connection-oriented. This
means it does not match well with Conn (TCP-like), or UDPConn (not
connection-oriented). In a pinch, it can be used as either. The
`transport.MsgConn` interface best captures the behavior of a transport
connection. The transport layer can run on top of a `net.UDPConn`, or another
`transport.MsgConn`. For more information, see its Godoc in the `transport`
directory.

The transport layer server needs to multiplex multiple connections on a single
UDP socket. This is similar to an operating system implementation of TCP,
multiplexing connections on a single L3 socket. Concurrency, error, and timeout
management is complicated and still needs work.

The transport layer uses client and server certificates for authentication,
following the Hop certificate specification (not X.509). For more information,
see the `certs` package.

### Tubes Layer

Hop Tubes are implemented in the `tubes` package. This contains the Tube
abstraction, which can reliable or unreliable. It is implemented on top of the
transport layer, and provides reliable stream-oriented connections.

### Hop Remote Access

_The structure of the Hop Application is subject to change, a lot!_

The Hop app is implemented across several packages and attempts to be an SSH
replacement. It uses the Hop Tubes layer, and the SSH terminal management
layers. SSH-like features are provided by the golang.org/x implementation. 
The client and server are in the `hopclient` and `hopserver` directories.

The client and server both read a configuration file, similar to SSH(D). The
configuration file parser is partially autogenerated. For more details, see the
`config` package.

## Where is `main`?

There are a variety of binaries available in the `cmd` package. Each should have
its own README. In general, keep the `main` packages short and sweet, and prefer
to keep most of the implementations in a standalone package that can be
unit-tested, and can share components with other binaries.

## File Structure

Each top-level folder should have its own README or a `doc.go` or both. Go
programs should have Go docs and a `doc.go` for package-level documentation.

[cyclist]: https://tosc.iacr.org/index.php/ToSC/article/view/8618/8184
[kravatte]: https://keccak.team/kravatte.html
